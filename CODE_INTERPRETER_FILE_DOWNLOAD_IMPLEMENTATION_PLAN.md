# Code Interpreter File Download Implementation Plan - REVISED ARCHITECTURE: MESSAGE-BASED DESIGN

## ✅ CURRENT STATUS OVERVIEW

### ✅ COMPLETED FEATURES

#### 1. Message-Based Auto-Prepare File System

- **Status**: ✅ FULLY IMPLEMENTED
- **Location**: `backend/open_webui/utils/code_interpreter.py`
- **Functionality**: Automatically prepares files attached to specific messages for code execution
- **Features**:
  - Message-specific file scanning via `get_attached_files_from_message(message_id, chat_id)`
  - Symlink creation for file access with Docker environment compatibility
  - Comprehensive filesystem testing and validation
  - Smart file linking with deduplication per message

#### 2. Message-Based Path Translation System

- **Status**: ✅ FULLY IMPLEMENTED
- **Location**: `EnterpriseGatewayCodeExecutor` class
- **Functionality**: Bidirectional path replacement between `/mnt/data` and message-specific workspace paths
- **Features**:
  - Code translation before execution: `/mnt/data` → `data/uploads/{message_id}`
  - Result translation after execution: `data/uploads/{message_id}` → `/mnt/data`
  - Transparent user experience with consistent `/mnt/data` paths
  - Message-level workspace isolation

#### 3. Message-Specific Workspaces

- **Status**: ✅ FULLY IMPLEMENTED
- **Location**: Integrated throughout code interpreter system
- **Functionality**: Isolated execution environments per message (not chat)
- **Directory Structure**: `data/uploads/{message_id}/` for each message execution
- **Benefits**: Complete isolation, no cross-message file contamination

#### 4. Enhanced Dynamic Prompt Strategy

- **Status**: ✅ UPDATED
- **Location**: `backend/open_webui/utils/middleware.py`
- **New Approach**: Message-specific file information injection via `generate_dynamic_code_interpreter_prompt()`
- **Features**:
  - Direct message file metadata access: `metadata.get("files", [])`
  - Message ID context: `metadata.get("message_id", "")`
  - Eliminates chat-level file scanning complexity

#### 5. Jupyter Gateway Focus with Message Isolation

- **Status**: ✅ CONFIRMED
- **Engine**: Jupyter/Enterprise Gateway (server-based) with message-specific file system access
- **Pyodide**: ❌ NOT MODIFIED (browser-based engine remains unchanged)
- **Image Handling**: Base64 image capture from matplotlib plots (existing cache system)
- **Message Context**: Each execution uses `workspace_id = message_id` for complete isolation

## 🔍 COMPATIBILITY ANALYSIS WITH MESSAGE-BASED SYSTEM

### ✅ What Works Better with Message-Based Design:

1. **Message-specific workspaces** - Perfect alignment with `data/uploads/{message_id}`
2. **Direct file access** - No scanning required, direct message file lookup
3. **Enhanced security** - Complete message-level isolation
4. **Simplified logic** - Eliminates complex chat history scanning
5. **Better performance** - Direct message file access vs chat scanning

### ⚠️ UPDATED INTEGRATION CONSIDERATIONS:

#### 1. **Message-Based File Storage System Integration**

Your existing system now leverages direct message file access instead of chat-level scanning, providing better precision and performance.

#### 2. **Workspace vs Storage Separation (Enhanced)**

- **Message Workspace**: `data/uploads/{message_id}/` (execution environment per message)
- **Storage**: Separate file storage with metadata tracking (unchanged)
- **Isolation**: Message-level boundaries instead of chat-level

#### 3. **Message-Scoped File Lifecycle Management**

New code-generated files are tied to specific messages for better organization and security.

## 🏗️ REVISED ARCHITECTURE: MESSAGE-FOCUSED NON-INVASIVE INTEGRATION

### UPDATED STANDALONE CLASS: `CodeGeneratedFileManager`

Enhanced for message-based architecture:

**UPDATED FILE NEEDED**: `backend/open_webui/utils/code_generated_file_manager.py`

```python
import os
import shutil
from typing import List, Dict, Set, Optional
from datetime import datetime
from pathlib import Path

from open_webui.models.files import Files
from open_webui.utils.misc import calculate_sha256
from open_webui.config import UPLOAD_DIR

class CodeGeneratedFileManager:
    """
    Manages files generated by code execution and integrates with existing file storage system.
    Enhanced for message-based architecture with complete message isolation.
    """

    TRACKED_EXTENSIONS = {'.xlsx', '.xls', '.csv', '.pdf'}

    def __init__(self, chat_id: str, user_id: str, workspace_path: str, message_id: str = ""):
        self.chat_id = chat_id
        self.message_id = message_id or chat_id  # Use message_id as primary identifier
        self.user_id = user_id
        self.workspace_path = workspace_path
        self.initial_files: Set[str] = set()
        self.final_files: Set[str] = set()

    def capture_pre_execution_state(self):
        """Capture message workspace state before code execution"""
        self.initial_files = set(self._scan_tracked_files())
        logger.info(f"Pre-execution state captured for message {self.message_id}, workspace: {self.workspace_path}")

    def capture_post_execution_state(self):
        """Capture message workspace state after code execution"""
        self.final_files = set(self._scan_tracked_files())
        logger.info(f"Post-execution state captured for message {self.message_id}")

    def _scan_tracked_files(self) -> List[str]:
        """Scan message workspace for Excel, CSV, PDF files"""
        tracked_files = []
        if not os.path.exists(self.workspace_path):
            return tracked_files

        for root, dirs, filenames in os.walk(self.workspace_path):
            for filename in filenames:
                ext = os.path.splitext(filename)[1].lower()
                if ext in self.TRACKED_EXTENSIONS:
                    rel_path = os.path.relpath(os.path.join(root, filename), self.workspace_path)
                    tracked_files.append(rel_path)
        return tracked_files

    def get_newly_generated_files(self) -> List[Dict]:
        """Get files created during message execution"""
        new_files = self.final_files - self.initial_files
        file_details = []

        for rel_path in new_files:
            full_path = os.path.join(self.workspace_path, rel_path)
            if os.path.isfile(full_path):
                file_info = self._create_file_info(rel_path, full_path)
                file_details.append(file_info)
                logger.info(f"Found newly generated file: {file_info['name']} (Message: {self.message_id})")

        return file_details

    def _create_file_info(self, rel_path: str, full_path: str) -> Dict:
        """Create file information dictionary with message context"""
        stat = os.stat(full_path)
        return {
            "name": os.path.basename(rel_path),
            "relative_path": rel_path,
            "full_path": full_path,
            "size": stat.st_size,
            "created_at": datetime.fromtimestamp(stat.st_ctime).isoformat(),
            "modified_at": datetime.fromtimestamp(stat.st_mtime).isoformat(),
            "mime_type": self._get_mime_type(rel_path),
            "format": self._get_format_type(rel_path),
            "extension": os.path.splitext(rel_path)[1].lower(),
            "message_id": self.message_id,  # Add message context
            "chat_id": self.chat_id
        }

    def register_files_to_storage(self, generated_files: List[Dict]) -> List[str]:
        """
        Register newly generated files with existing file storage system.
        Enhanced with message-based metadata.
        Returns list of file_ids for the registered files.
        """
        registered_file_ids = []

        for file_info in generated_files:
            try:
                # Copy file to permanent storage location
                file_id = self._copy_to_permanent_storage(file_info)

                # Register with existing Files model with message context
                db_file_id = self._register_with_file_model(file_info, file_id)
                registered_file_ids.append(db_file_id)
                logger.info(f"Registered file {file_info['name']} with ID {db_file_id} for message {self.message_id}")

            except Exception as e:
                logger.error(f"Failed to register file {file_info['name']} for message {self.message_id}: {e}")
                registered_file_ids.append(None)

        return registered_file_ids

    def _copy_to_permanent_storage(self, file_info: Dict) -> str:
        """Copy file from message workspace to permanent storage"""
        # Generate unique file ID with message context
        file_content = open(file_info['full_path'], 'rb').read()
        file_hash = calculate_sha256(file_content)
        file_id = f"code_gen_{self.message_id}_{file_hash[:16]}"

        # Create permanent storage path
        permanent_dir = os.path.join(UPLOAD_DIR, "code_generated")
        os.makedirs(permanent_dir, exist_ok=True)

        # Copy file to permanent location
        permanent_path = os.path.join(permanent_dir, file_id)
        shutil.copy2(file_info['full_path'], permanent_path)
        logger.info(f"Copied {file_info['name']} to permanent storage: {permanent_path}")

        return file_id

    def _register_with_file_model(self, file_info: Dict, file_id: str) -> str:
        """Register file with existing Files model/database with message metadata"""
        try:
            file_record = Files.insert_new_file(
                user_id=self.user_id,
                form_data={
                    "file_id": file_id,
                    "filename": file_info['name'],
                    "content_type": file_info['mime_type'],
                    "size": file_info['size'],
                    "meta": {
                        "source": "code_execution",
                        "chat_id": self.chat_id,
                        "message_id": self.message_id,  # Enhanced with message context
                        "generated_at": file_info['created_at'],
                        "format": file_info['format'],
                        "original_workspace_path": file_info['relative_path'],
                        "workspace_id": self.message_id  # Primary identifier
                    }
                }
            )
            return file_record.id
        except Exception as e:
            logger.error(f"Failed to register file in database for message {self.message_id}: {e}")
            return None

    # ...existing methods remain the same...

    @classmethod
    def cleanup_message_workspace_files(cls, message_id: str, keep_days: int = 7):
        """Clean up old message workspace files (enhanced cleanup utility)"""
        workspace_path = os.path.join(UPLOAD_DIR, "uploads", message_id)
        if not os.path.exists(workspace_path):
            return

        cutoff_time = datetime.now().timestamp() - (keep_days * 24 * 60 * 60)

        for root, dirs, files in os.walk(workspace_path):
            for file in files:
                file_path = os.path.join(root, file)
                if os.path.getctime(file_path) < cutoff_time:
                    try:
                        os.remove(file_path)
                        logger.debug(f"Cleaned up old file: {file_path}")
                    except OSError:
                        pass
```

### ENHANCED INTEGRATION WITH MESSAGE-BASED CODE INTERPRETER

**UPDATED FILE**: `backend/open_webui/utils/code_interpreter.py`

```python
# ...existing imports and code...

class EnterpriseGatewayCodeExecutor:
    """
    Execute code in Jupyter Enterprise Gateway with message-based file management
    """

    def __init__(
        self,
        # ...existing parameters...
        message_id: str = "",  # Enhanced with message_id
        chat_id: str = "",     # Keep for compatibility
        attached_files: List[Dict[str, Any]] = None,
    ):
        # ...existing initialization...

        # Use message_id as primary workspace identifier
        self.workspace_id = message_id or chat_id or str(uuid.uuid4())
        self.message_id = message_id
        self.chat_id = chat_id
        self.attached_files = attached_files or []

        # Initialize file manager with message context
        self.file_manager = None
        if self.workspace_id and self.user_id:
            workspace_path = os.path.join(self.data_dir, "uploads", self.workspace_id)
            self.file_manager = CodeGeneratedFileManager(
                chat_id=self.chat_id,
                message_id=self.message_id,  # Enhanced with message context
                user_id=self.user_id,
                workspace_path=workspace_path,
            )

        # ...existing code...

    async def run(self) -> ResultModel:
        """Enhanced run method with message-based file tracking"""
        try:
            # Auto-prepare message-specific files first
            await self._auto_prepare_files()

            # Capture pre-execution state for message workspace
            if self.file_manager:
                logger.info(f"Starting file tracking for message {self.message_id}, workspace: {self.workspace_id}")
                self.file_manager.capture_pre_execution_state()

            # ...existing execution code unchanged...
            await self.setup_auth()
            await self.init_kernel()
            await self.execute_code()

            # Capture post-execution state and register generated files
            if self.file_manager:
                logger.info("Capturing post-execution state for message-based file tracking")
                self.file_manager.capture_post_execution_state()
                generated_files = self.file_manager.get_newly_generated_files()

                if generated_files:
                    logger.info(f"Found {len(generated_files)} newly generated files for message {self.message_id}")

                    # Register files to storage with message context
                    registered_file_ids = self.file_manager.register_files_to_storage(generated_files)

                    # Add file information to the result
                    if not hasattr(self.result, "files"):
                        self.result.files = []

                    for file_info, file_id in zip(generated_files, registered_file_ids):
                        if file_id:
                            file_data = {
                                "id": file_id,
                                "name": file_info["name"],
                                "url": f"/api/v1/files/{file_id}/content",
                                "size": file_info["size"],
                                "format": file_info["format"],
                                "message_id": self.message_id,  # Enhanced with message context
                                "chat_id": self.chat_id
                            }
                            self.result.files.append(file_data)
                            logger.info(f"Added file to result: {file_data}")

                    logger.info(f"Successfully registered {len([fid for fid in registered_file_ids if fid])} files to storage for message {self.message_id}")
                else:
                    logger.info(f"No new files generated during execution for message {self.message_id}")

        except Exception as err:
            logger.exception(f"Execute code failed for message {self.message_id}: {err}")
            self.result.stderr = f"Error: {err}"

        return self.result

# Updated main execution function
async def execute_code_jupyter(
    base_url: str,
    code: str,
    token: str = "",
    password: str = "",
    timeout: int = 60,
    message_id: str = "",  # Enhanced parameter
    chat_id: str = "",     # Keep for compatibility
    data_dir: str = "data",
    kernel_init_code: str = "",
    user_id: str = "",
) -> dict:
    # Get attached files from the specific message
    attached_files = []
    if message_id and chat_id:
        attached_files = get_attached_files_from_message(message_id, chat_id)

    # Use message_id as primary workspace_id
    workspace_id = message_id or str(uuid.uuid4())

    async with EnterpriseGatewayCodeExecutor(
        base_url,
        code,
        token,
        password,
        timeout,
        workspace_id=workspace_id,
        message_id=message_id,  # Enhanced with message context
        chat_id=chat_id,
        data_dir=data_dir,
        kernel_init_code=kernel_init_code,
        user_id=user_id,
        attached_files=attached_files,
    ) as executor:
        result = await executor.run()
        return result.model_dump()
```

### ENHANCED DOWNLOAD API WITH MESSAGE-BASED ORGANIZATION

**UPDATED FILE**: `backend/open_webui/routers/downloads.py`

```python
from fastapi import APIRouter, HTTPException, Depends
from fastapi.responses import FileResponse
from open_webui.models.files import Files
from open_webui.utils.auth import get_current_user

router = APIRouter()

@router.get("/code-execution/{message_id}/files")
async def list_generated_files_by_message(
    message_id: str,
    user=Depends(get_current_user)
):
    """List files generated by code execution for a specific message"""
    # Query existing Files model for message-specific code-generated files
    files = Files.get_files_by_user_id(user.id)

    message_generated_files = [
        f for f in files
        if f.meta and f.meta.get('source') == 'code_execution'
        and f.meta.get('message_id') == message_id  # Enhanced message filtering
    ]

    return [
        {
            "id": f.id,
            "name": f.filename,
            "size": f.size,
            "format": f.meta.get('format', 'Unknown'),
            "created_at": f.created_at.isoformat(),
            "message_id": f.meta.get('message_id'),
            "chat_id": f.meta.get('chat_id'),
            "download_url": f"/api/v1/downloads/code-execution/file/{f.id}"
        }
        for f in message_generated_files
    ]

@router.get("/code-execution/chat/{chat_id}/files")
async def list_generated_files_by_chat(
    chat_id: str,
    user=Depends(get_current_user)
):
    """List all files generated by code execution across messages in a chat"""
    files = Files.get_files_by_user_id(user.id)

    chat_generated_files = [
        f for f in files
        if f.meta and f.meta.get('source') == 'code_execution'
        and f.meta.get('chat_id') == chat_id
    ]

    # Group by message for better organization
    message_groups = {}
    for f in chat_generated_files:
        msg_id = f.meta.get('message_id', 'unknown')
        if msg_id not in message_groups:
            message_groups[msg_id] = []

        message_groups[msg_id].append({
            "id": f.id,
            "name": f.filename,
            "size": f.size,
            "format": f.meta.get('format', 'Unknown'),
            "created_at": f.created_at.isoformat(),
            "message_id": f.meta.get('message_id'),
            "download_url": f"/api/v1/downloads/code-execution/file/{f.id}"
        })

    return {
        "chat_id": chat_id,
        "total_files": len(chat_generated_files),
        "messages": message_groups
    }

@router.get("/code-execution/file/{file_id}")
async def download_generated_file(
    file_id: str,
    user=Depends(get_current_user)
):
    """Download code-generated file using existing file system"""
    # Use existing file retrieval logic
    file_record = Files.get_file_by_id(file_id)

    if not file_record or file_record.user_id != user.id:
        raise HTTPException(status_code=404, detail="File not found")

    # Verify it's a code-generated file
    if not (file_record.meta and file_record.meta.get('source') == 'code_execution'):
        raise HTTPException(status_code=403, detail="Not a code-generated file")

    # Use existing file serving logic
    return Files.serve_file(file_record)
```

## ✅ BENEFITS OF MESSAGE-BASED ARCHITECTURE:

1. **Complete Message Isolation**: Each message execution is completely isolated from others
2. **Precise File Access**: Only files attached to the specific message are available
3. **Enhanced Security**: No cross-message file contamination possible
4. **Simplified Logic**: Direct message file lookup eliminates chat scanning complexity
5. **Better Performance**: No need to scan entire chat history for files
6. **Clear Organization**: Files are organized by message for better user experience
7. **Workspace Efficiency**: Each message gets its own clean workspace
8. **Storage Integration**: Message-based metadata in existing file storage system

## 🔧 UPDATED IMPLEMENTATION CHECKLIST:

- [x] Create message-based file scanning function ✅ DONE
- [x] Update workspace creation to use message_id ✅ DONE
- [x] Enhance path translation for message workspaces ✅ DONE
- [x] Update middleware to pass message-specific files ✅ DONE
- [x] Modify frontend to send message_id and chat_id ✅ DONE
- [ ] **ENHANCE**: `CodeGeneratedFileManager` with message context
- [ ] **UPDATE**: Download API for message-based file organization
- [ ] **TEST**: Message-specific file generation → storage → download workflow

## 🎯 UPDATED IMPLEMENTATION PRIORITIES

### ✅ WEEK 1: Message-Based File Manager Integration (Build on Enhanced System)

- [x] Message-based auto-prepare system ✅ DONE
- [x] Message-specific path translation ✅ DONE
- [x] Message workspace isolation ✅ DONE
- [x] Message file scanning implementation ✅ DONE
- [ ] **ENHANCE**: `CodeGeneratedFileManager` class with message context
- [ ] **UPDATE**: Executor enhancement for message-based tracking
- [ ] **TEST**: Message-specific file creation → storage integration

### 🔄 WEEK 2: Message-Organized Download API

- [ ] **ENHANCE**: Downloads router with message-based endpoints
- [ ] **ADD**: Message-specific file listing and serving
- [ ] **ADD**: Chat-level file organization (grouped by message)
- [ ] **TEST**: End-to-end message file generation → storage → download
- [ ] **VERIFY**: Message-level security and user isolation

### 📦 WEEK 3: Frontend and Message Integration

- [ ] **ENHANCE**: `CodeBlock.svelte` with message-aware file panel
- [ ] **ADD**: Message-specific file detection and UI
- [ ] **TEST**: Complete user workflow with message isolation
- [ ] **OPTIMIZE**: Performance and message workspace cleanup

## 🔑 LEVERAGING MESSAGE-BASED INFRASTRUCTURE

This message-focused approach enhances all your existing strengths:

1. **✅ Message File Access**: Enhanced auto-prepare system handles message-specific input files
2. **✅ Message Path Consistency**: Path translation ensures `/mnt/data` works with message workspaces
3. **✅ Message Isolation**: Complete message-specific workspace isolation for security
4. **✅ Storage Integration**: New files automatically enter existing file system with message metadata
5. **✅ User Management**: Files properly owned and secured by user with message context
6. **✅ Cleanup Systems**: Existing file cleanup enhanced with message workspace management

The message-based approach delivers superior isolation, better performance, and cleaner architecture while providing exactly what users need: downloadable business files (Excel, CSV, PDF) when they explicitly request them, organized by message for optimal user experience.
