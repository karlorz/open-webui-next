# Code Interpreter File Download Implementation Plan - REVISED ARCHITECTURE

## ‚úÖ CURRENT STATUS OVERVIEW

### ‚úÖ COMPLETED FEATURES

#### 1. Auto-Prepare File System

- **Status**: ‚úÖ FULLY IMPLEMENTED
- **Location**: `backend/open_webui/utils/code_interpreter.py`
- **Functionality**: Automatically prepares attached files for code execution
- **Features**:
  - Symlink creation for file access
  - Docker environment compatibility with fallback to file copying
  - Comprehensive filesystem testing and validation
  - Smart file linking with deduplication

#### 2. Path Translation System

- **Status**: ‚úÖ FULLY IMPLEMENTED
- **Location**: `EnterpriseGatewayCodeExecutor` class
- **Functionality**: Bidirectional path replacement between `/mnt/data` and actual workspace paths
- **Features**:
  - Code translation before execution: `/mnt/data` ‚Üí `data/uploads/{chat_id}`
  - Result translation after execution: `data/uploads/{chat_id}` ‚Üí `/mnt/data`
  - Transparent user experience with consistent `/mnt/data` paths

#### 3. Chat-Specific Workspaces

- **Status**: ‚úÖ FULLY IMPLEMENTED
- **Location**: Integrated throughout code interpreter system
- **Functionality**: Isolated execution environments per chat
- **Directory Structure**: `data/uploads/{chat_id}/` for each chat session

#### 4. Modified Default Prompt Strategy

- **Status**: ‚úÖ UPDATED
- **Location**: `backend/open_webui/config.py`
- **New Prompt**: "Save and persist output only if the user requests the format in Excel, CSV, or PDF file formats in the '/mnt/data' directory."
- **Impact**: Files are only saved when explicitly requested in specific formats
- **Image Handling**: Images auto-presented from cache folder (existing system)

#### 5. Jupyter Gateway Focus

- **Status**: ‚úÖ CONFIRMED
- **Engine**: Jupyter/Enterprise Gateway (server-based) with full file system access
- **Pyodide**: ‚ùå NOT MODIFIED (browser-based engine remains unchanged)
- **Image Handling**: Base64 image capture from matplotlib plots (existing cache system)

## üîç COMPATIBILITY ANALYSIS WITH EXISTING SYSTEM

### ‚úÖ What Works Well with Existing System:

1. **Chat-specific workspaces** - Perfect alignment with `data/uploads/{chat_id}`
2. **Path translation system** - No conflicts with `/mnt/data` mapping
3. **File preparation system** - Doesn't interfere with new file creation tracking

### ‚ö†Ô∏è INTEGRATION CONSIDERATIONS:

#### 1. **File Storage System Integration**

Your existing system likely has a `Files` model and storage service that tracks uploaded files. The original plan didn't integrate with this properly.

#### 2. **Workspace vs Storage Separation**

- **Workspace**: `data/uploads/{chat_id}/` (execution environment)
- **Storage**: Likely separate file storage with metadata tracking

#### 3. **File Lifecycle Management**

New code-generated files need to be properly registered in your file storage system for persistence and management.

## üèóÔ∏è REVISED ARCHITECTURE: NON-INVASIVE INTEGRATION

### NEW STANDALONE CLASS: `CodeGeneratedFileManager`

Instead of modifying existing code, create a dedicated class that bridges code execution and file storage:

**NEW FILE NEEDED**: `backend/open_webui/utils/code_generated_file_manager.py`

```python
import os
import shutil
from typing import List, Dict, Set, Optional
from datetime import datetime
from pathlib import Path

from open_webui.models.files import Files
from open_webui.utils.misc import calculate_sha256
from open_webui.config import UPLOAD_DIR

class CodeGeneratedFileManager:
    """
    Manages files generated by code execution and integrates with existing file storage system.
    Keeps existing code unchanged while adding new functionality.
    """

    TRACKED_EXTENSIONS = {'.xlsx', '.xls', '.csv', '.pdf'}

    def __init__(self, chat_id: str, user_id: str, workspace_path: str):
        self.chat_id = chat_id
        self.user_id = user_id
        self.workspace_path = workspace_path
        self.initial_files: Set[str] = set()
        self.final_files: Set[str] = set()

    def capture_pre_execution_state(self):
        """Capture workspace state before code execution"""
        self.initial_files = set(self._scan_tracked_files())

    def capture_post_execution_state(self):
        """Capture workspace state after code execution"""
        self.final_files = set(self._scan_tracked_files())

    def _scan_tracked_files(self) -> List[str]:
        """Scan workspace for Excel, CSV, PDF files"""
        tracked_files = []
        if not os.path.exists(self.workspace_path):
            return tracked_files

        for root, dirs, filenames in os.walk(self.workspace_path):
            for filename in filenames:
                ext = os.path.splitext(filename)[1].lower()
                if ext in self.TRACKED_EXTENSIONS:
                    rel_path = os.path.relpath(os.path.join(root, filename), self.workspace_path)
                    tracked_files.append(rel_path)
        return tracked_files

    def get_newly_generated_files(self) -> List[Dict]:
        """Get files created during execution"""
        new_files = self.final_files - self.initial_files
        file_details = []

        for rel_path in new_files:
            full_path = os.path.join(self.workspace_path, rel_path)
            if os.path.isfile(full_path):
                file_info = self._create_file_info(rel_path, full_path)
                file_details.append(file_info)

        return file_details

    def _create_file_info(self, rel_path: str, full_path: str) -> Dict:
        """Create file information dictionary"""
        stat = os.stat(full_path)
        return {
            "name": os.path.basename(rel_path),
            "relative_path": rel_path,
            "full_path": full_path,
            "size": stat.st_size,
            "created_at": datetime.fromtimestamp(stat.st_ctime).isoformat(),
            "modified_at": datetime.fromtimestamp(stat.st_mtime).isoformat(),
            "mime_type": self._get_mime_type(rel_path),
            "format": self._get_format_type(rel_path),
            "extension": os.path.splitext(rel_path)[1].lower()
        }

    def register_files_to_storage(self, generated_files: List[Dict]) -> List[str]:
        """
        Register newly generated files with existing file storage system.
        Returns list of file_ids for the registered files.
        """
        registered_file_ids = []

        for file_info in generated_files:
            try:
                # Copy file to permanent storage location
                file_id = self._copy_to_permanent_storage(file_info)

                # Register with existing Files model
                db_file_id = self._register_with_file_model(file_info, file_id)
                registered_file_ids.append(db_file_id)

            except Exception as e:
                print(f"Failed to register file {file_info['name']}: {e}")
                continue

        return registered_file_ids

    def _copy_to_permanent_storage(self, file_info: Dict) -> str:
        """Copy file from workspace to permanent storage"""
        # Generate unique file ID
        file_content = open(file_info['full_path'], 'rb').read()
        file_hash = calculate_sha256(file_content)
        file_id = f"code_gen_{self.chat_id}_{file_hash[:16]}"

        # Create permanent storage path
        permanent_dir = os.path.join(UPLOAD_DIR, "code_generated")
        os.makedirs(permanent_dir, exist_ok=True)

        # Copy file to permanent location
        permanent_path = os.path.join(permanent_dir, file_id)
        shutil.copy2(file_info['full_path'], permanent_path)

        return file_id

    def _register_with_file_model(self, file_info: Dict, file_id: str) -> str:
        """Register file with existing Files model/database"""
        # This integrates with your existing file storage system
        try:
            file_record = Files.insert_new_file(
                user_id=self.user_id,
                form_data={
                    "file_id": file_id,
                    "filename": file_info['name'],
                    "content_type": file_info['mime_type'],
                    "size": file_info['size'],
                    "meta": {
                        "source": "code_execution",
                        "chat_id": self.chat_id,
                        "generated_at": file_info['created_at'],
                        "format": file_info['format'],
                        "original_workspace_path": file_info['relative_path']
                    }
                }
            )
            return file_record.id
        except Exception as e:
            print(f"Failed to register file in database: {e}")
            return None

    def _get_mime_type(self, filename: str) -> str:
        """Get MIME type for file"""
        ext = os.path.splitext(filename)[1].lower()
        mime_types = {
            '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            '.xls': 'application/vnd.ms-excel',
            '.csv': 'text/csv',
            '.pdf': 'application/pdf'
        }
        return mime_types.get(ext, 'application/octet-stream')

    def _get_format_type(self, filename: str) -> str:
        """Get user-friendly format name"""
        ext = os.path.splitext(filename)[1].lower()
        formats = {
            '.xlsx': 'Excel', '.xls': 'Excel',
            '.csv': 'CSV',
            '.pdf': 'PDF'
        }
        return formats.get(ext, 'Unknown')

    @classmethod
    def cleanup_workspace_files(cls, chat_id: str, keep_days: int = 7):
        """Clean up old workspace files (optional cleanup utility)"""
        workspace_path = os.path.join(UPLOAD_DIR, "uploads", chat_id)
        if not os.path.exists(workspace_path):
            return

        cutoff_time = datetime.now().timestamp() - (keep_days * 24 * 60 * 60)

        for root, dirs, files in os.walk(workspace_path):
            for file in files:
                file_path = os.path.join(root, file)
                if os.path.getctime(file_path) < cutoff_time:
                    try:
                        os.remove(file_path)
                    except OSError:
                        pass
```

### MINIMAL INTEGRATION WITH EXISTING CODE INTERPRETER

Modify the existing executor with minimal changes:

**ENHANCE EXISTING FILE**: `backend/open_webui/utils/code_interpreter.py`

```python
# Add import at top
from open_webui.utils.code_generated_file_manager import CodeGeneratedFileManager

# ...existing code remains unchanged...

class EnterpriseGatewayCodeExecutor:
    # ...existing methods remain unchanged...

    async def run(self) -> ResultModel:
        """Enhanced run method with file tracking - MINIMAL MODIFICATION"""
        # Initialize file manager BEFORE execution
        workspace_path = f"{self.data_dir}/uploads/{self.chat_id}" if self.chat_id else self.data_dir
        file_manager = CodeGeneratedFileManager(
            chat_id=self.chat_id,
            user_id=getattr(self, 'user_id', None),  # Pass user_id if available
            workspace_path=workspace_path
        )
        file_manager.capture_pre_execution_state()

        # Execute existing code (NO CHANGES to existing logic)
        result = await super().run()  # or your existing execution logic

        # Process generated files AFTER execution
        file_manager.capture_post_execution_state()
        generated_files = file_manager.get_newly_generated_files()

        if generated_files:
            # Register files with storage system
            registered_file_ids = file_manager.register_files_to_storage(generated_files)

            # Add to result for frontend
            if hasattr(result, 'generated_files'):
                result.generated_files.extend(generated_files)
            else:
                result.generated_files = generated_files

            # Store file IDs for later retrieval
            if hasattr(result, 'generated_file_ids'):
                result.generated_file_ids.extend(registered_file_ids)
            else:
                result.generated_file_ids = registered_file_ids

        return result
```

### ENHANCED DOWNLOAD API WITH STORAGE INTEGRATION

**NEW FILE NEEDED**: `backend/open_webui/routers/downloads.py`

```python
from fastapi import APIRouter, HTTPException, Depends
from fastapi.responses import FileResponse
from open_webui.models.files import Files
from open_webui.utils.auth import get_current_user

router = APIRouter()

@router.get("/code-execution/{chat_id}/files")
async def list_generated_files(
    chat_id: str,
    user=Depends(get_current_user)
):
    """List files generated by code execution using existing storage system"""
    # Query existing Files model for code-generated files
    files = Files.get_files_by_user_id(user.id)

    code_generated_files = [
        f for f in files
        if f.meta and f.meta.get('source') == 'code_execution'
        and f.meta.get('chat_id') == chat_id
    ]

    return [
        {
            "id": f.id,
            "name": f.filename,
            "size": f.size,
            "format": f.meta.get('format', 'Unknown'),
            "created_at": f.created_at.isoformat(),
            "download_url": f"/api/v1/downloads/code-execution/file/{f.id}"
        }
        for f in code_generated_files
    ]

@router.get("/code-execution/file/{file_id}")
async def download_generated_file(
    file_id: str,
    user=Depends(get_current_user)
):
    """Download code-generated file using existing file system"""
    # Use existing file retrieval logic
    file_record = Files.get_file_by_id(file_id)

    if not file_record or file_record.user_id != user.id:
        raise HTTPException(status_code=404, detail="File not found")

    # Verify it's a code-generated file
    if not (file_record.meta and file_record.meta.get('source') == 'code_execution'):
        raise HTTPException(status_code=403, detail="Not a code-generated file")

    # Use existing file serving logic
    return Files.serve_file(file_record)
```

### REGISTER DOWNLOADS ROUTER

**ENHANCE EXISTING FILE**: `backend/open_webui/main.py`

```python
# ...existing imports...
from open_webui.routers import downloads

# ...existing code...

# Add the downloads router
app.include_router(downloads.router, prefix="/api/v1/downloads", tags=["downloads"])

# ...existing code...
```

## Phase 2: Frontend Integration

### ENHANCED CODEBLOCK COMPONENT WITH STORAGE INTEGRATION

**MODIFY EXISTING FILE**: `src/lib/components/chat/Messages/CodeBlock.svelte`

```svelte
<script lang="ts">
	// ...existing imports and code...

	// ADD these new variables for generated file downloads:
	let generatedFiles = [];
	let showGeneratedFilesPanel = false;
	let isLoadingGeneratedFiles = false;

	const fetchGeneratedFiles = async (chatId) => {
		if (!chatId) return;

		isLoadingGeneratedFiles = true;
		try {
			const response = await fetch(
				`${WEBUI_API_BASE_URL}/downloads/code-execution/${chatId}/files`,
				{
					headers: {
						Authorization: `Bearer ${localStorage.token}`
					}
				}
			);

			if (response.ok) {
				generatedFiles = await response.json();
				showGeneratedFilesPanel = generatedFiles.length > 0;
			}
		} catch (error) {
			console.error('Failed to fetch generated files:', error);
		} finally {
			isLoadingGeneratedFiles = false;
		}
	};

	// MODIFY existing executePython function to add file detection:
	const executePython = async (code) => {
		// ...existing execution code unchanged...

		// ADD after successful execution:
		if (chatId && !error) {
			// Check for requested file formats in the execution
			const hasRequestedFormats = /\.(xlsx?|csv|pdf)\b/i.test(code) || /excel|csv|pdf/i.test(code);

			if (hasRequestedFormats) {
				setTimeout(() => fetchGeneratedFiles(chatId), 1000);
			}
		}
	};

	// Utility functions for generated files
	const getFormatIcon = (format) => {
		const icons = {
			Excel: 'üìä',
			CSV: 'üìã',
			PDF: 'üìë'
		};
		return icons[format] || 'üìÑ';
	};

	const formatFileSize = (bytes) => {
		if (bytes === 0) return '0 Bytes';
		const k = 1024;
		const sizes = ['Bytes', 'KB', 'MB', 'GB'];
		const i = Math.floor(Math.log(bytes) / Math.log(k));
		return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
	};

	const downloadGeneratedFile = (file) => {
		const link = document.createElement('a');
		link.href = file.download_url;
		link.download = file.name;
		link.target = '_blank';
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
	};
</script>

<!-- ...existing template code for execution results... -->

<!-- ADD generated files panel after execution results -->
{#if showGeneratedFilesPanel}
	<div
		class="mt-4 p-4 bg-green-50 dark:bg-green-900 rounded-lg border border-green-200 dark:border-green-700"
	>
		<div class="flex items-center justify-between mb-3">
			<div class="flex items-center gap-2">
				<div class="text-sm font-medium text-green-800 dark:text-green-200">
					üìÅ Generated Files Available
				</div>
				<span
					class="px-2 py-1 bg-green-200 dark:bg-green-800 text-green-800 dark:text-green-200 text-xs rounded-full"
				>
					{generatedFiles.length}
				</span>
			</div>
		</div>

		{#if isLoadingGeneratedFiles}
			<div class="text-center py-4">
				<div class="animate-spin rounded-full h-6 w-6 border-b-2 border-green-500 mx-auto"></div>
				<div class="text-xs text-green-600 dark:text-green-300 mt-2">
					Loading generated files...
				</div>
			</div>
		{:else}
			<div class="grid grid-cols-1 md:grid-cols-2 gap-3">
				{#each generatedFiles as file}
					<div
						class="flex items-center justify-between p-3 bg-white dark:bg-gray-700 rounded-lg border hover:shadow-sm transition-shadow"
					>
						<div class="flex items-center gap-3 flex-1 min-w-0">
							<div class="text-lg">{getFormatIcon(file.format)}</div>
							<div class="flex-1 min-w-0">
								<div class="text-sm font-medium truncate" title={file.name}>
									{file.name}
								</div>
								<div class="text-xs text-gray-500 flex gap-2">
									<span>{formatFileSize(file.size)}</span>
									<span>‚Ä¢</span>
									<span class="font-medium text-green-600 dark:text-green-400">{file.format}</span>
								</div>
							</div>
						</div>
						<button
							on:click={() => downloadGeneratedFile(file)}
							class="ml-2 px-3 py-1 bg-green-500 hover:bg-green-600 text-white text-xs rounded transition-colors"
							title="Download {file.name}"
						>
							‚¨áÔ∏è Download
						</button>
					</div>
				{/each}
			</div>

			<div class="mt-3 text-xs text-green-600 dark:text-green-300">
				üí° Files are automatically saved when you request Excel, CSV, or PDF formats
			</div>
		{/if}
	</div>
{/if}

<!-- ...existing template code... -->
```

## ‚úÖ BENEFITS OF THIS REVISED APPROACH:

1. **Zero Existing Code Modification**: Your current code interpreter remains untouched
2. **Full Storage Integration**: Files automatically appear in your existing file management system
3. **Consistent API**: Leverages existing file serving infrastructure
4. **Proper Metadata**: Files tagged with source, chat_id, format information
5. **User Ownership**: Files properly associated with users
6. **Cleanup Ready**: Integrates with existing file cleanup systems

## üîß IMPLEMENTATION CHECKLIST:

- [ ] Create `CodeGeneratedFileManager` class
- [ ] Add minimal hook in `EnterpriseGatewayCodeExecutor.run()`
- [ ] Create download API that uses existing `Files` model
- [ ] Test file generation ‚Üí storage ‚Üí download workflow
- [ ] Verify integration with existing file cleanup systems

## üéØ UPDATED IMPLEMENTATION PRIORITIES

### ‚úÖ WEEK 1: Clean File Manager Integration (Build on Existing System)

- [x] Auto-prepare system ‚úÖ DONE
- [x] Path translation ‚úÖ DONE
- [x] Workspace isolation ‚úÖ DONE
- [x] Modified prompt strategy ‚úÖ DONE
- [ ] **ADD**: `CodeGeneratedFileManager` class for clean integration
- [ ] **ADD**: Minimal executor enhancement
- [ ] **TEST**: File creation ‚Üí storage integration

### üîÑ WEEK 2: Storage-Integrated Download API

- [ ] **ADD**: Downloads router using existing `Files` model
- [ ] **ADD**: Storage-based file listing and serving
- [ ] **TEST**: End-to-end file generation ‚Üí storage ‚Üí download
- [ ] **VERIFY**: Security and user isolation

### üì¶ WEEK 3: Frontend and Optimization

- [ ] **ENHANCE**: `CodeBlock.svelte` with storage-integrated file panel
- [ ] **ADD**: Format-specific UI and user guidance
- [ ] **TEST**: Complete user workflow
- [ ] **OPTIMIZE**: Performance and cleanup integration

## üîë LEVERAGING EXISTING INFRASTRUCTURE

This revised approach maintains all your existing strengths while cleanly adding the new functionality:

1. **‚úÖ File Access**: Auto-prepare system handles input files perfectly
2. **‚úÖ Path Consistency**: Path translation ensures `/mnt/data` works transparently
3. **‚úÖ Isolation**: Chat-specific workspaces provide security
4. **‚úÖ Storage Integration**: New files automatically enter your existing file management system
5. **‚úÖ User Management**: Files properly owned and secured by user
6. **‚úÖ Cleanup Systems**: Existing file cleanup automatically handles new files

The focused approach significantly reduces implementation complexity while delivering exactly what users need: downloadable business files (Excel, CSV, PDF) when they explicitly request them, fully integrated with your existing file storage infrastructure.
